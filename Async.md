## 1.1 分块的程序
考虑以下代码：
```javascript
function now() { 
    return 21; 
} 
 
function later() { 
    answer = answer * 2; 
    console.log( "Meaning of life:", answer ); 
} 
 
var answer = now(); 
 
setTimeout( later, 1000 ); // Meaning of life: 42
``` 
这个程序有两个块：现在执行的部分，以及将来执行的部分。这两块的内容很明显，但这里我们还是要明确指出来。
现在：
```javascript
function now() { 
    return 21; 
} 
 
function later() { .. } 
 
var answer = now(); 
 
setTimeout( later, 1000 );
```
将来：
```javascript
answer = answer * 2; 
console.log( "Meaning of life:", answer );
```

## 1.3 并行线程

“异步”和“并行”意义完全不同。**异步**是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。

并行计算最常见的工具就是 _线程和进程_，进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同计算机上，但多个线程能够共享单个进程的内存。
>与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共享。

同一段代码又两个可能输出意味着还是存在不确定性！但是，这种不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别(或者说，表达式运算顺序级别)。换句话说，这一确定性要高于多线程情况。
在JavaScript的特性中，这种函数顺序的不确定性就是通常所说的竞态条件，foo()和bar()相互竞争，看谁先运行。具体来说，因为无法可靠预测 a 和 b的最终结果，所以才是竞态条件。

## 1.4 并发

现在让我们来设想一个展示状态更新列表（比如社交网络新闻种子）的网站，其随着用户向下滚动列表而逐渐加载更多内容。要正确地实现这一特性，需要（至少）两个独立的“进程”同时运行（也就是说，是在同一段时间内，并不需要在同一时刻）。

第一个“进程”在用户向下滚动页面触发onscroll事件时响应这些事件(发起Ajax请求新的内容)。第二个“进程”接收Ajax响应(把内容展示到页面)。

### 1.4.2 交互

可以协调交互顺序来处理这样的竞态条件：
```javascript
var res = []
function response(data) {
  if( data.url === "http://some.url.1"){
    res[0] = data
  }
  else if(data.url === "http://some.url.1"){
    res[1] = data
  }
}
// ajax(..)是某个库中提供的某个Ajax函数 
ajax( "http://some.url.1", response );  
ajax( "http://some.url.2", response ); 
``` 
不管哪一个Ajax响应先返回，我们都要通过查看data.url判断应该把响应数据放在res数组中的什么位置上。

### 1.4.3 协作
还有一种并发合作方式，称为并发协作(cooperative concurency)。这里的重点不再是通过共享作用域中的值进行交互(尽管显然这也是允许的！)。这里的目标是取到一个长期允许的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。

## 1.5 任务
在ES6中，有一个新的概念建立在事件循环队列智商，叫做 _任务队列job queue_。这个概念给大家带来的最大影响可能是Promoise的异步特性。
对于 _任务队列_ 最好的理解方式就是，它是挂在 _事件循环_ 队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目(一个任务)。

事件循环队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。

## 1.7
实际上，JavaScript程序总是至少分为两个快：第一块 _现在运行_；下一块 _将来运行_，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累计的修改之上进行的。

一旦有事件需要运行，事件循环就会运行，知道队列清空。事件循环的每一轮称为一个tick。用户交互、IO和定时器会向事件队列中加入事件。

任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。

并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。

通常需要对这些并发执行的"进程"(有别于操作系统中的进程概念)进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竟态出现。这些“进程”也可以通过把自身分隔为更小的块，以便其他“进程”插入进来。